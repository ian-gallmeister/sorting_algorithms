import random
import numpy as np

from datetime import datetime
from skimage import color #For HSV
from scipy.misc import imsave #For HSV

FRAMES=160
SORT_ALG='bubblesort'
# bubblesort | 
#SIZE='large' #512x512 from start
SIZE='small' #Start with 16x16

#Dimensions for large and small
LARGE=512
SMALL=16

#TODO - implement more algorithms

def main():

  img = shuffled_image()

  max_moves, moves = sort_rows( img )
  print( '{now} Max Moves to Sort: {mm}'.format(now=now(),mm=max_moves) )

  #5 second gif, 24 fps, 120 frames
  #If faster than 32x32 worst-case scenario, record every step
  if max_moves <= 528:
    movie_image_step = 1
  else:
    movie_image_step = max_moves // FRAMES
  frame_number = 0
  
  print( '{now} Applying position swaps to image ...'.format(now=now()) )
  current_move = 0
  while current_move <= max_moves:
    img = apply_swaps( img, moves, current_move )
    #If we're at a save-step
    if current_move % movie_image_step == 0:
      frame_number = save_image( img, frame_number )
    current_move += 1

def now():
  return datetime.now().strftime( '%Y/%m/%d %H:%M:%S' )

def shuffled_image():
  if SIZE == 'large':
    dim=LARGE
  elif SIZE == 'small':
    dim=SMALL
  #Create image, set colors, shuffle
  print( '{now} Creating image ...'.format(now=now()) )
  img = np.zeros((dim,dim,3), dtype='float32')
  print( '{now}  ... setting colors'.format(now=now()) )
  for i in range(img.shape[1]):
    img[:,i,:] = i / img.shape[1], 1.0, 1.0
  print( '{now}  ... shuffling rows'.format(now=now())  )
  for i in range(img.shape[0]):
    np.random.shuffle( img[i,:,:] )
  return img
  
def sort_rows( img ):
  moves = []
  max_moves = 0
  print( '{now} Sorting rows ...'.format(now=now()) )
  for i in range(img.shape[0]):
    _, rowsort = sort( list(img[i,:,0]) )
    moves.append(rowsort)
    if len( rowsort ) > max_moves:
      max_moves = len(rowsort)
  return max_moves, moves

def save_image( img, frame_num ):
  print( '{now}  ... saving frame {num}.png'.format(now=now(), num=str(frame_num).zfill(3)) )
  saveimg = expand_image( img )  #If small, is expanded
  imsave( '{dir}/{fn}.png'.format(dir=SORT_ALG, fn=str(frame_num).zfill(3)), color.convert_colorspace(saveimg, 'HSV', 'RGB') )
  return frame_num + 1

def apply_swaps( img, moves, current_move ):
  for i in range(img.shape[0]):
    if current_move < len(moves[i]):
      img = swap_pixels(i, moves[i][current_move], img )
  return img

  return seq, swaps

#To sort columns
#Row is constant
#Places is an entry from swaps[] generated by bubblesort
def swap_pixels( row, places, img ):
  tmp = img[row,places[0],:].copy() #A single pixel
  img[row,places[0],:] = img[row,places[1],:]
  img[row,places[1],:] = tmp
  return img

#Turns 32x32 into 512x512 (16 times larger)
def expand_image( img ):
  #Not creating a monster image
  if img.shape[0] > 32:
    return img
  print( '{now}  ... expanding image for large square pixels'.format(now=now()) )
  newimg = np.zeros((16*img.shape[0],16*img.shape[1],3), dtype='float32')
  for i in range(img.shape[0]):   #Row
    for j in range(img.shape[1]): #Col
      for x in range(16*i, 16*i+16):   #new_row
        for y in range(16*j, 16*j+16): #new_col
          newimg[x][y] = img[i][j]
  return newimg


def sort( seq ): #To swap algorithms
  if SORT_ALG == 'bubblesort':
    return bubblesort( seq )

#Need to record each position swap as well
#Moves smallest to the left, progressively 
#stops checking lowest as goes
def bubblesort( seq ):
  swaps = []
  for x in range(len(seq)):
    for y in range(len(seq)-1,x,-1):
      if seq[y] < seq[y-1]:
        swaps.append([y, y-1])
        tmp = seq[y]
        seq[y] = seq[y-1]
        seq[y-1] = tmp
      #print( '{} - pass_number={}, list_index={}'.format(seq, x, y) )

def heapsort( seq ):
  swaps = []


if __name__ == '__main__':
  main()
